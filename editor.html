<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Ubicaciones - Sistema</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; } /* bg-slate-900 */
        .grid-cell { min-height: 40px; min-width: 40px; }
        .grid-cell.drag-over { background-color: #2563eb30; border-color: #2563eb; }
        .adding-mode { cursor: copy; }
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.7); }
    </style>
</head>
<body class="text-gray-200">

    <div id="root"></div>

    <script type="text/babel">
        window.onload = function() {
            const { useState, useEffect, useRef } = React;

            const SVG_ICONS = {
                Save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" />',
                Loader: '<path d="M12 2v4" /><path d="m16.2 7.8 2.8-2.8" /><path d="M18 12h4" /><path d="m16.2 16.2 2.8 2.8" /><path d="M12 18v4" /><path d="m7.8 16.2-2.8 2.8" /><path d="M6 12H2" /><path d="m7.8 7.8-2.8-2.8" />',
                Trash2: '<path d="M3 6h18" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" /><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" />',
                PlusCircle: '<circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="16" /><line x1="8" y1="12" x2="16" y2="12" />',
                Menu: '<line x1="4" x2="20" y1="12" y2="12" /><line x1="4" x2="20" y1="6" y2="6" /><line x1="4" x2="20" y1="18" y2="18" />',
                CircleUser: '<circle cx="12" cy="12" r="10"/><circle cx="12" cy="10" r="3"/><path d="M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662"/>',
                UtensilsCrossed: '<path d="m16 2-2.3 2.3a3 3 0 0 0 0 4.2l1.8 1.8a3 3 0 0 0 4.2 0L22 8" /><path d="M15 15 3.3 3.3a4.2 4.2 0 0 0 0 6l7.3 7.3c.7.7 2 .7 2.8 0L15 15Zm0 0 7 7" /><path d="m2.1 2.1 6.4 6.4" />',
                X: '<path d="M18 6 6 18" /><path d="m6 6 12 12" />',
                Armchair: '<path d="M19 9V6a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v3" /><path d="M3 16a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2Z" /><path d="M5 11v-2" /><path d="M19 9v2" />',
                Beer: '<path d="M17 11h1a3 3 0 0 1 0 6h-1" /><path d="M9 12v6" /><path d="M13 12v6" /><path d="M14 7.5c0-.28.22-.5.5-.5h1c.28 0 .5.22.5.5c0 .28-.22.5-.5.5h-1c-.28 0-.5-.22-.5-.5Z" /><path d="M12 20a6 6 0 0 1-6-6V7H4v10a8 8 0 0 0 8 8Z" />',
                MapPin: '<path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" /><circle cx="12" cy="10" r="3" />',
                LayoutGrid: '<rect width="7" height="7" x="3" y="3" rx="1" /><rect width="7" height="7" x="14" y="3" rx="1" /><rect width="7" height="7" x="14" y="14" rx="1" /><rect width="7" height="7" x="3" y="14" rx="1" />',
                Pencil: '<path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" />',
                SquareX: '<rect width="18" height="18" x="3" y="3" rx="2" /><path d="m15 9-6 6" /><path d="m9 9 6 6" />',
                Table: '<path d="M20 10.5h-2V7a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v3.5H4a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h2v2.5a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V17.5h2a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1Z"/>',
                TriangleAlert: '<path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><path d="M12 9v4" /><path d="M12 17h.01" />',
                BarTopView: '<rect x="1" y="7" width="22" height="14" rx="1" stroke-width="1.5" fill="none" /><line x1="1" y1="13" x2="23" y2="13" stroke-width="1.5" /><circle cx="5" cy="4" r="2" /><circle cx="12" cy="4" r="2" /><circle cx="19" cy="4" r="2" /><circle cx="4" cy="10" r="1" /><circle cx="7" cy="10" r="1" /><circle cx="10" cy="10" r="1" /><circle cx="13" cy="10" r="1" /><circle cx="16" cy="10" r="1" /><circle cx="19" cy="10" r="1" /><circle cx="5" cy="16" r="1.2" /><circle cx="9" cy="16" r="1.2" /><circle cx="13" cy="16" r="1.2" /><circle cx="17" cy="16" r="1.2" />',
                PlantTopView2: '<circle cx="12" cy="12" r="10" stroke-width="1.5"/><g transform="rotate(0 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g><g transform="rotate(50 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g><g transform="rotate(100 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g><g transform="rotate(150 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g><g transform="rotate(200 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g><g transform="rotate(250 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g><g transform="rotate(300 12 12)"><path d="M12 12 Q 10 7, 10 3" stroke-width="1" fill="none"/><path d="M11 5 L 9 4" stroke-width="0.8"/><path d="M11 7 L 9 6" stroke-width="0.8"/><path d="M11 9 L 9 8" stroke-width="0.8"/></g>',
                FountainTopView: '<circle cx="12" cy="12" r="10" stroke-width="1.5" fill="none"/><circle cx="12" cy="12" r="6" stroke-width="1" fill="none"/><circle cx="12" cy="12" r="2" fill="currentColor"/><path d="M12 8 V 6 M16 12 H 18 M12 16 V 18 M8 12 H 6" stroke-width="1"/>',
                GardenTopView: '<rect x="1" y="1" width="22" height="22" rx="1" stroke-width="1" fill="none"/><g stroke-width="0.5" fill="currentColor"><g transform="translate(7 7)"><circle cx="0" cy="0" r="1"/><circle cx="1" cy="1" r="0.5"/><circle cx="-1" cy="1" r="0.5"/><circle cx="1" cy="-1" r="0.5"/><circle cx="-1" cy="-1" r="0.5"/></g><g transform="translate(17 7)"><circle cx="0" cy="0" r="1"/><circle cx="1" cy="1" r="0.5"/><circle cx="-1" cy="1" r="0.5"/><circle cx="1" cy="-1" r="0.5"/><circle cx="-1" cy="-1" r="0.5"/></g><g transform="translate(7 17)"><circle cx="0" cy="0" r="1"/><circle cx="1" cy="1" r="0.5"/><circle cx="-1" cy="1" r="0.5"/><circle cx="1" cy="-1" r="0.5"/><circle cx="-1" cy="-1" r="0.5"/></g><g transform="translate(17 17)"><circle cx="0" cy="0" r="1"/><circle cx="1" cy="1" r="0.5"/><circle cx="-1" cy="1" r="0.5"/><circle cx="1" cy="-1" r="0.5"/><circle cx="-1" cy="-1" r="0.5"/></g></g><circle cx="4" cy="4" r="1.5" stroke-width="1"/><circle cx="12" cy="4" r="1.5" stroke-width="1"/><circle cx="20" cy="4" r="1.5" stroke-width="1"/><circle cx="4" cy="12" r="1.5" stroke-width="1"/><circle cx="20" cy="12" r="1.5" stroke-width="1"/>'
            };

            const Icon = ({ name, className = '', ...props }) => (
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className={className}
                    {...props}
                    dangerouslySetInnerHTML={{ __html: SVG_ICONS[name] || '' }}
                />
            );

            function AddZoneModal({ show, onClose, value, onChange, onSave }) {
                const inputRef = useRef(null);
                useEffect(() => {
                    if (show) setTimeout(() => inputRef.current?.focus(), 50);
                }, [show]);

                if (!show) return null;
                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-md p-6">
                            <h3 className="text-lg font-medium text-white mb-4">Crear Nueva Zona</h3>
                            <input ref={inputRef} type="text" value={value} onChange={onChange} placeholder="Nombre de la zona (ej: Terraza)" className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-3 mb-4 placeholder-gray-400" />
                            <div className="flex justify-end gap-3">
                                <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                <button onClick={onSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Guardar</button>
                            </div>
                        </div>
                    </div>
                );
            }

            function RenameZoneModal({ show, onClose, value, onChange, onSave }) {
                const inputRef = useRef(null);
                useEffect(() => {
                    if (show) {
                        setTimeout(() => inputRef.current?.focus(), 50);
                    }
                }, [show]);

                if (!show) return null;
                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-md p-6">
                            <h3 className="text-lg font-medium text-white mb-4">Renombrar Zona</h3>
                            <input ref={inputRef} type="text" value={value} onChange={onChange} className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-3 mb-4 placeholder-gray-400" />
                            <div className="flex justify-end gap-3">
                                <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                <button onClick={onSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Guardar</button>
                            </div>
                        </div>
                    </div>
                );
            }

            function EditDecorationModal({ show, onClose, decoration, onSave, onDelete }) {
                const [editedDecoration, setEditedDecoration] = useState(decoration);

                useEffect(() => {
                    setEditedDecoration(decoration);
                }, [decoration]);

                if (!show || !editedDecoration) return null;

                const handleSave = () => {
                    onSave({
                        ...editedDecoration,
                        width: parseInt(editedDecoration.width, 10) || 1,
                        height: parseInt(editedDecoration.height, 10) || 1,
                    });
                };

                const handleChange = (e) => {
                    const { name, value } = e.target;
                    setEditedDecoration(prev => ({ ...prev, [name]: value }));
                };

                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-lg p-6 space-y-4">
                            <h3 className="text-xl font-semibold text-white">Editar Decoración</h3>
                            <div className="flex gap-4">
                                <div className="flex-1">
                                    <label className="block text-sm font-medium text-gray-300">Ancho (celdas)</label>
                                    <input type="number" name="width" value={editedDecoration.width ?? ''} onChange={handleChange} className="mt-1 block w-full px-3 py-2 bg-slate-700 border border-slate-600 text-white rounded-md shadow-sm focus:outline-none focus:ring-cyan-500 focus:border-cyan-500" />
                                </div>
                                <div className="flex-1">
                                    <label className="block text-sm font-medium text-gray-300">Alto (celdas)</label>
                                    <input type="number" name="height" value={editedDecoration.height ?? ''} onChange={handleChange} className="mt-1 block w-full px-3 py-2 bg-slate-700 border border-slate-600 text-white rounded-md shadow-sm focus:outline-none focus:ring-cyan-500 focus:border-cyan-500" />
                                </div>
                            </div>
                            <div className="flex justify-between items-center pt-4">
                                <button onClick={() => onDelete(editedDecoration.id)} className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white flex items-center gap-2">
                                    <Icon name="Trash2" className="w-4 h-4"/> Eliminar
                                </button>
                                <div className="flex gap-3">
                                    <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                    <button onClick={handleSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Guardar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            function EditTableModal({ show, onClose, table, onSave, onDelete }) {
                const [tableName, setTableName] = useState('');
                const [tableShape, setTableShape] = useState('square');
                const inputRef = useRef(null);

                useEffect(() => {
                    if (table) {
                        setTableName(table.number);
                        setTableShape(table.shape || 'square');
                    }
                }, [table]);

                useEffect(() => {
                    if (show) {
                        setTimeout(() => inputRef.current?.focus(), 50);
                    }
                }, [show]);

                if (!show || !table) return null;

                const handleSave = () => {
                    onSave(table.id, tableName, tableShape);
                    onClose();
                };

                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-md p-6">
                            <h3 className="text-lg font-medium text-white mb-4">Editar Mesa</h3>
                            <input
                                ref={inputRef}
                                type="text"
                                value={tableName}
                                onChange={(e) => setTableName(e.target.value)}
                                className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-3 mb-4 placeholder-gray-400"
                            />
                            <div className="my-4">
                                <label htmlFor="table-shape" className="block mb-2 text-sm font-medium text-white">Forma de la Mesa</label>
                                <select id="table-shape" value={tableShape} onChange={(e) => setTableShape(e.target.value)} className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-2.5">
                                    <option value="square">Cuadrada (2x2)</option>
                                    <option value="rectangle">Rectangular (4x2)</option>
                                    <option value="rectangle_vertical">Rectangular (2x4)</option>
                                </select>
                            </div>
                            <div className="flex justify-between items-center">
                                <button onClick={() => onDelete(table.id)} className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white flex items-center gap-2">
                                    <Icon name="Trash2" className="w-4 h-4"/> Eliminar
                                </button>
                                <div className="flex gap-3">
                                    <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                    <button onClick={handleSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Guardar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            function ZoneActionsModal({ show, onClose, value, onChange, onSave, onDelete }) {
                const inputRef = useRef(null);

                useEffect(() => {
                    if (show) {
                        setTimeout(() => inputRef.current?.focus(), 50);
                    }
                }, [show]);

                if (!show) return null;

                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-md p-6">
                            <h3 className="text-lg font-medium text-white mb-4">Gestionar Zona</h3>
                            <input
                                ref={inputRef}
                                type="text"
                                value={value}
                                onChange={onChange}
                                className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-3 mb-4 placeholder-gray-400"
                            />
                            <div className="flex justify-between items-center">
                                <button onClick={onDelete} className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white flex items-center gap-2">
                                    <Icon name="Trash2" className="w-4 h-4"/> Eliminar
                                </button>
                                <div className="flex gap-3">
                                    <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                    <button onClick={onSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Guardar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            const DECORATION_TYPES = {
                'bar': { name: 'Barra', icon: 'BarTopView', width: 6, height: 6, isSvgIcon: true },
                'plant': { name: 'Planta', icon: 'PlantTopView2', width: 2, height: 2, isSvgIcon: true },
                'fountain': { name: 'Fuente', icon: 'FountainTopView', width: 3, height: 3, isSvgIcon: true },
                'garden': { name: 'Jardín', icon: 'GardenTopView', width: 5, height: 5, isSvgIcon: true }
            };

            function AddDecorationModal({ show, onClose, onSave }) {
                const [decorationType, setDecorationType] = useState(Object.keys(DECORATION_TYPES)[0]);

                if (!show) return null;

                const handleSave = () => {
                    onSave(decorationType);
                    onClose();
                };

                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-md p-6">
                            <h3 className="text-lg font-medium text-white mb-4">Añadir Decoración</h3>
                            <div className="my-4">
                                <label htmlFor="decoration-type" className="block mb-2 text-sm font-medium text-white">Tipo de Elemento</label>
                                <select
                                    id="decoration-type"
                                    value={decorationType}
                                    onChange={(e) => setDecorationType(e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-2.5"
                                >
                                    {Object.entries(DECORATION_TYPES).map(([key, { name, icon, isDrawable }]) => (
                                        <option key={key} value={key}>
                                            {name}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <div className="flex justify-end gap-3">
                                <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                <button onClick={handleSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Añadir</button>
                            </div>
                        </div>
                    </div>
                );
            }

            function AddTableModal({ show, onClose, onSave }) {
                const [tableName, setTableName] = useState('');
                const [tableShape, setTableShape] = useState('square');
                const inputRef = useRef(null);

                useEffect(() => {
                    if (show) {
                        setTableName('');
                        setTableShape('square');
                        setTimeout(() => inputRef.current?.focus(), 50);
                    }
                }, [show]);

                if (!show) return null;

                const handleSave = () => {
                    if (tableName.trim()) {
                        onSave(tableName, tableShape);
                        onClose();
                    } else {
                        alert("El nombre de la mesa no puede estar vacío.");
                    }
                };

                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-md p-6">
                            <h3 className="text-lg font-medium text-white mb-4">Añadir Nueva Mesa</h3>
                            <input
                                ref={inputRef}
                                type="text"
                                value={tableName}
                                onChange={(e) => setTableName(e.target.value)}
                                placeholder="Ej: M1, B2..."
                                className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-3 mb-4 placeholder-gray-400"
                            />
                            <div className="my-4">
                                <label htmlFor="add-table-shape" className="block mb-2 text-sm font-medium text-white">Forma</label>
                                <select
                                    id="add-table-shape"
                                    value={tableShape}
                                    onChange={(e) => setTableShape(e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block p-2.5"
                                >
                                    <option value="square">Cuadrada (2x2)</option>
                                    <option value="rectangle">Rectangular (4x2)</option>
                                    <option value="rectangle_vertical">Rectangular (2x4)</option>
                                </select>
                            </div>
                            <div className="flex justify-end gap-3">
                                <button onClick={onClose} className="px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-500 text-white">Cancelar</button>
                                <button onClick={handleSave} className="px-4 py-2 rounded-lg bg-cyan-600 hover:bg-cyan-700 text-white">Guardar</button>
                            </div>
                        </div>
                    </div>
                );
            }

            function DeleteZoneModal({ show, onClose, onConfirm, zoneName }) {
                if (!show) return null;
                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6 text-center">
                            <Icon name="TriangleAlert" className="mx-auto mb-4 h-14 w-14 text-red-500" />
                            <h3 className="mb-5 text-lg font-normal text-gray-300">¿Seguro que quieres eliminar la zona "{zoneName}"?</h3>
                            <p className="text-sm text-gray-500 mb-6">Esta acción no se puede deshacer.</p>
                            <div className="flex justify-center gap-4">
                                <button onClick={onClose} className="px-5 py-2.5 rounded-lg bg-gray-600 hover:bg-gray-500 text-white">Cancelar</button>
                                <button onClick={onConfirm} className="px-5 py-2.5 rounded-lg bg-red-600 hover:bg-red-700 text-white">Sí, eliminar</button>
                            </div>
                        </div>
                    </div>
                );
            }

            function DeleteWallModal({ show, onClose, onConfirm }) {
                if (!show) return null;
                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-6 text-center">
                            <Icon name="TriangleAlert" className="mx-auto mb-4 h-14 w-14 text-red-500" />
                            <h3 className="mb-5 text-lg font-normal text-gray-800">¿Seguro que quieres eliminar esta pared?</h3>
                            <p className="text-sm text-gray-500 mb-6">Esta acción no se puede deshacer.</p>
                            <div className="flex justify-center gap-4">
                                <button onClick={onClose} className="px-5 py-2.5 rounded-lg bg-gray-200 hover:bg-gray-300 text-gray-800">Cancelar</button>
                                <button onClick={onConfirm} className="px-5 py-2.5 rounded-lg bg-red-600 hover:bg-red-700 text-white">Sí, eliminar</button>
                            </div>
                        </div>
                    </div>
                );
            }

            const getInitials = (name) => {
                if (!name) return '';
                const words = name.trim().split(' ');
                if (words.length > 1) {
                    return words.map(word => word[0]).join('').toUpperCase().substring(0, 2);
                }
                return name.substring(0, 2).toUpperCase();
            };

            const Sidebar = ({
                zones, activeZoneId, setActiveZoneId,
                isAddingMode, setIsAddingMode,
                isAddingDecorationMode, setIsAddingDecorationMode,
                isAddingWallMode, setIsAddingWallMode,
                selectedTable, setSelectedTable,
                setShowAddZoneModal, setShowDeleteZoneModal, setZoneToEdit, setShowZoneActionsModal,
                isSidebarOpen, setIsSidebarOpen,
                handleSaveChanges, isDirty, isSaving
            }) => {

                const handleZoneClick = (zoneId) => {
                    setActiveZoneId(zoneId);
                    setSelectedTable(null);
                    setIsAddingMode(false);
                };

                return (
                    <div className={`fixed top-0 left-0 z-40 h-screen bg-slate-800 border-r border-slate-700 shadow-sm transition-all duration-300 ${isSidebarOpen ? 'w-64' : 'w-20'}`}>
                        <div className="flex flex-col h-full p-4">
                            <div>
                                <div className={`flex items-center mb-6 h-[2.125rem] ${isSidebarOpen ? 'justify-between' : 'justify-center'} lg:justify-start`}>
                                    <a href="#" className={`flex items-center ps-2.5`}>
                                        <span className={`self-center text-2xl font-semibold whitespace-nowrap text-white ${isSidebarOpen ? 'inline' : 'hidden'}`}>ZONAS</span>
                                    </a>
                                    <button onClick={() => setIsSidebarOpen(prev => !prev)} className={`p-2 rounded-md hover:bg-gray-700`}>
                                        <Icon name={isSidebarOpen ? 'X' : 'Menu'} className="w-6 h-6 text-white" />
                                    </button>
                                </div>
                                <ul className="space-y-3 font-medium">
                                    {zones.map(zone => (
                                        <li key={zone.id}>
                                            <button
                                                onClick={() => handleZoneClick(zone.id)}
                                                onDoubleClick={() => { setZoneToEdit({ id: zone.id, name: zone.name }); setShowZoneActionsModal(true); }}
                                                className={`w-full flex items-center p-3 text-white rounded-lg group transition-colors ${activeZoneId === zone.id ? 'bg-cyan-500' : 'hover:bg-slate-700'} ${!isSidebarOpen && 'justify-center'}`}>
                                                <Icon name={zone.name === 'Salón' ? 'Armchair' : zone.name.includes('Barra') ? 'Beer' : 'MapPin'} className={`flex-shrink-0 w-8 h-8 transition duration-75 ${activeZoneId === zone.id ? 'text-white' : 'text-gray-400 group-hover:text-white'}`} />
                                                <span className={`flex-1 ms-3 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>{zone.name}</span>
                                                <span className={`text-sm font-semibold whitespace-nowrap ${!isSidebarOpen ? 'inline' : 'hidden'}`}>{getInitials(zone.name)}</span>
                                            </button>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                            <div className="mt-auto pt-4">
                                <div className="space-y-3">
                                    <h3 className={`text-lg font-semibold text-white mb-2 px-2 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>Herramientas</h3>
                                                                        <button onClick={() => { setIsAddingMode(prev => !prev); setIsAddingDecorationMode(false); setIsAddingWallMode(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${isAddingMode ? 'bg-cyan-500 text-white' : 'bg-slate-700 hover:bg-slate-600 text-white'} ${!isSidebarOpen && 'justify-center'}`}><Icon name="Table" className="flex-shrink-0" /> <span className={`ms-3 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>Añadir Mesa</span></button>
                                                                        <button onClick={() => { setIsAddingDecorationMode(prev => !prev); setIsAddingMode(false); setIsAddingWallMode(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${isAddingDecorationMode ? 'bg-purple-500 text-white' : 'bg-slate-700 hover:bg-slate-600 text-white'} ${!isSidebarOpen && 'justify-center'}`}><Icon name="PlusCircle" className="flex-shrink-0" /> <span className={`ms-3 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>Añadir Decoración</span></button>
                                                                        <button onClick={() => { setIsAddingWallMode(prev => !prev); setIsAddingMode(false); setIsAddingDecorationMode(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${isAddingWallMode ? 'bg-yellow-500 text-white' : 'bg-slate-700 hover:bg-slate-600 text-white'} ${!isSidebarOpen && 'justify-center'}`}><Icon name="Pencil" className="flex-shrink-0" /> <span className={`ms-3 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>Añadir Pared</span></button>
                                </div>
                                <div className="space-y-3 pt-4 mt-4 border-t border-slate-700">
                                    <button onClick={() => setShowAddZoneModal(true)} className={`w-full flex items-center p-3 rounded-lg bg-blue-500 hover:bg-blue-600 text-white justify-center`}><Icon name="LayoutGrid" className="flex-shrink-0" /> <span className={`ms-3 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>Nueva Zona</span></button>
                                    <button onClick={handleSaveChanges} disabled={!isDirty || isSaving} className={`w-full flex items-center p-3 rounded-lg transition-colors text-white disabled:opacity-50 ${isDirty ? 'bg-green-500 hover:bg-green-600' : 'bg-slate-700 hover:bg-slate-600'} justify-center`}>
                                        {isSaving ? 
                                            <Icon name="Loader" className="animate-spin flex-shrink-0" /> : 
                                            <Icon name="Save" className="flex-shrink-0" />
                                        }
                                        <span className={`ms-3 whitespace-nowrap ${isSidebarOpen ? 'inline' : 'hidden'}`}>{isSaving ? 'Guardando...' : 'Guardar Cambios'}</span>
                                        {!isSaving && isDirty && <span className={`w-3 h-3 bg-yellow-400 rounded-full ms-auto ${isSidebarOpen ? 'inline' : 'hidden'}`}/>}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            function Header({ activeZoneName, isSidebarOpen, setIsSidebarOpen }) {
                return (
                    <header className="flex items-center justify-between p-4 bg-white/80 backdrop-blur-sm border-b border-gray-200/80 lg:hidden">
                        <h1 className="text-xl font-bold text-gray-900">{activeZoneName}</h1>
                        <a href="#" className="p-2 rounded-full hover:bg-gray-700">
                            <Icon name="CircleUser" className="w-6 h-6" />
                        </a>
                    </header>
                );
            }

            function LayoutEditor() {
                const [zones, setZones] = useState([]);
                const [activeZoneId, setActiveZoneId] = useState(null);
                const [loading, setLoading] = useState(true);
                const [isSidebarOpen, setIsSidebarOpen] = useState(window.innerWidth >= 1024);

                const getInitials = (name) => {
                    if (!name) return '';
                    const words = name.split(' ');
                    if (words.length > 1) {
                        return words.map(word => word[0]).join('').toUpperCase();
                    }
                    return name.substring(0, 2).toUpperCase();
                };
                const [isAddingMode, setIsAddingMode] = useState(false);
                const [selectedTable, setSelectedTable] = useState(null);
                const [showAddZoneModal, setShowAddZoneModal] = useState(false);
                const [newZoneName, setNewZoneName] = useState('');
                const [showDeleteZoneModal, setShowDeleteZoneModal] = useState(false);
                const [zoneToEdit, setZoneToEdit] = useState({ id: null, name: '' });
                const [isDirty, setIsDirty] = useState(false);
                const [isSaving, setIsSaving] = useState(false);
                const [showEditTableModal, setShowEditTableModal] = useState(false);
                const [tableToEdit, setTableToEdit] = useState(null);
                const [showZoneActionsModal, setShowZoneActionsModal] = useState(false);
                const [showAddTableModal, setShowAddTableModal] = useState(false);
                const [newTableCoords, setNewTableCoords] = useState(null);
                const [isAddingDecorationMode, setIsAddingDecorationMode] = useState(false);
                const [showAddDecorationModal, setShowAddDecorationModal] = useState(false);
                const [newDecorationCoords, setNewDecorationCoords] = useState(null);
                const [showEditDecorationModal, setShowEditDecorationModal] = useState(false);
                const [decorationToEdit, setDecorationToEdit] = useState(null);
                const [isAddingWallMode, setIsAddingWallMode] = useState(false);
                const [isDrawingWall, setIsDrawingWall] = useState(false);
                const [wallDrawing, setWallDrawing] = useState(null);
                const [selectedWallId, setSelectedWallId] = useState(null);
                const [showDeleteWallModal, setShowDeleteWallModal] = useState(false);

                const NUM_COLS = 32;
                const NUM_ROWS = 20;

                const API_URL = 'api/plano.php';

                const fetchData = () => {
                    setLoading(true);
                    fetch(API_URL)
                        .then(res => res.json())
                        .then(data => {
                            const sanitizedZones = (data || []).map(zone => ({
                                ...zone,
                                tables: (zone.tables || []).map(t => ({ ...t, x: t.x ?? (t.col - 1) * 40, y: t.y ?? (t.row - 1) * 40 })),
                                decorations: (zone.decorations || []).map(d => ({ ...d, x: d.x ?? (d.col - 1) * 40, y: d.y ?? (d.row - 1) * 40 })),
                                walls: zone.walls || []
                            }));
                            setZones(sanitizedZones);
                            if (sanitizedZones.length > 0) {
                                setActiveZoneId(sanitizedZones[0].id);
                            }
                            setLoading(false);
                            setIsDirty(false);
                        })
                        .catch(err => {
                            console.error("Error fetching data:", err);
                            setLoading(false);
                        });
                };

                useEffect(() => {
                    fetchData();
                }, []);

                if (loading) {
                    return (
                        <div className="flex items-center justify-center h-screen bg-gray-900 text-white text-xl">
                            Cargando datos del plano...
                        </div>
                    );
                }

                const handleDragStart = (e, itemId, itemType) => {
                    e.dataTransfer.setData("itemId", itemId);
                    e.dataTransfer.setData("itemType", itemType);
                    const rect = e.currentTarget.getBoundingClientRect();
                    const offsetX = e.clientX - rect.left;
                    const offsetY = e.clientY - rect.top;
                    e.dataTransfer.setData("offsetX", offsetX.toString());
                    e.dataTransfer.setData("offsetY", offsetY.toString());
                    e.dataTransfer.effectAllowed = 'move';

                    if (itemType === 'table') {
                        setSelectedTable(itemId);
                    } else {
                        setSelectedTable(null);
                    }
                };

                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };

                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };

                const getItemRect = (item, itemType) => {
                    if (itemType === 'table') {
                        let width = 80, height = 80; // Default to square 2x2
                        if (item.shape === 'rectangle') { // 4x2
                            width = 160;
                            height = 80;
                        } else if (item.shape === 'rectangle_vertical') { // 2x4
                            width = 80;
                            height = 160;
                        }
                        return { x: item.x, y: item.y, width, height, id: item.id };
                    }
                    if (itemType === 'decoration') {
                        const typeInfo = DECORATION_TYPES[item.type];
                        if (!typeInfo) return { x: item.x, y: item.y, width: 0, height: 0, id: item.id };
                        return { x: item.x, y: item.y, width: typeInfo.width * 40, height: typeInfo.height * 40, id: item.id };
                    }
                    return { x: 0, y: 0, width: 0, height: 0, id: null };
                };

                const getWallRect = (wall) => {
                    const isHorizontal = wall.startRow === wall.endRow;
                    return {
                        x: (Math.min(wall.startCol, wall.endCol) - 1) * 40,
                        y: (Math.min(wall.startRow, wall.endRow) - 1) * 40,
                        width: isHorizontal ? (Math.abs(wall.endCol - wall.startCol) + 1) * 40 : 5,
                        height: isHorizontal ? 5 : (Math.abs(wall.endRow - wall.startRow) + 1) * 40,
                        id: wall.id
                    };
                };

                const doRectsOverlap = (rect1, rect2) => {
                    return (
                        rect1.x < rect2.x + rect2.width &&
                        rect1.x + rect1.width > rect2.x &&
                        rect1.y < rect2.y + rect2.height &&
                        rect1.y + rect1.height > rect2.y
                    );
                };

                const isPositionOccupied = (newItemRect, excludingId) => {
                    const activeZone = zones.find(z => z.id === activeZoneId);
                    if (!activeZone) return true;

                    for (const table of activeZone.tables) {
                        if (table.id === excludingId) continue;
                        if (doRectsOverlap(newItemRect, getItemRect(table, 'table'))) return true;
                    }

                    if (activeZone.decorations) {
                        for (const deco of activeZone.decorations) {
                            if (deco.id === excludingId) continue;
                            const decoRect = getItemRect(deco, 'decoration');
                            if (doRectsOverlap(newItemRect, decoRect)) return true;
                        }
                    }

                    if (activeZone.walls) {
                        for (const wall of activeZone.walls) {
                            if (wall.id === excludingId) continue;
                            const wallRect = getWallRect(wall);
                            if (doRectsOverlap(newItemRect, wallRect)) return true;
                        }
                    }

                    return false;
                };

                const handleMouseMoveOnGrid = (e) => {
                    if (!isDrawingWall || !wallDrawing) return;

                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const col = Math.floor(x / 40) + 1;
                    const row = Math.floor(y / 40) + 1;

                    const isHorizontal = Math.abs(col - wallDrawing.startCol) >= Math.abs(row - wallDrawing.startRow);
                    
                    const newEndCol = isHorizontal ? col : wallDrawing.startCol;
                    const newEndRow = isHorizontal ? wallDrawing.startRow : row;

                    setWallDrawing(prev => ({
                        ...prev,
                        endCol: newEndCol,
                        endRow: newEndRow
                    }));
                };

                const handleMouseUpOnGrid = () => {
                    if (!isDrawingWall || !wallDrawing) return;

                    setIsDrawingWall(false);

                    if (wallDrawing.startCol === wallDrawing.endCol && wallDrawing.startRow === wallDrawing.endRow) {
                        setWallDrawing(null);
                        return;
                    }

                    const newWall = {
                        id: `wall-${Date.now()}`,
                        type: 'wall',
                        ...wallDrawing
                    };

                    const wallRect = getWallRect(newWall);
                    if (isPositionOccupied(wallRect, null)) {
                        alert("No se puede crear una pared aquí, el espacio está ocupado.");
                        setWallDrawing(null);
                        return;
                    }

                    setZones(prevZones => prevZones.map(zone => {
                        if (zone.id === activeZoneId) {
                            return {
                                ...zone,
                                walls: [...(zone.walls || []), newWall]
                            };
                        }
                        return zone;
                    }));

                    setWallDrawing(null);
                    setIsDirty(true);
                    setIsAddingWallMode(false);
                };

                const handleMouseDownOnGrid = (e) => {
                    if (!isAddingWallMode) return;

                    const rect = e.currentTarget.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    const startCol = Math.floor(currentX / 40) + 1;
                    const startRow = Math.floor(currentY / 40) + 1;

                    setIsDrawingWall(true);
                    setWallDrawing({ startRow, startCol, endRow: startRow, endCol: startCol });
                };

                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    const itemId = e.dataTransfer.getData("itemId");
                    const itemType = e.dataTransfer.getData("itemType");
                    const offsetX = parseFloat(e.dataTransfer.getData("offsetX"));
                    const offsetY = parseFloat(e.dataTransfer.getData("offsetY"));

                    const gridRect = e.currentTarget.getBoundingClientRect();
                    const newX = Math.round((e.clientX - gridRect.left - offsetX) / 40) * 40;
                    const newY = Math.round((e.clientY - gridRect.top - offsetY) / 40) * 40;

                    const updatedZones = zones.map(zone => {
                        if (zone.id !== activeZoneId) return zone;

                        let item, itemRect;
                        let items, setItems;

                        if (itemType === 'table') {
                            items = zone.tables;
                            item = items.find(t => t.id == itemId);
                        } else {
                            items = zone.decorations;
                            item = items.find(d => d.id == itemId);
                        }

                        if (!item) return zone;

                        const tempItem = { ...item, x: newX, y: newY };
                        if (itemType === 'table') {
                            itemRect = getItemRect({ ...item, x: newX, y: newY }, 'table');
                        } else {
                            itemRect = getItemRect(tempItem, itemType);
                        }

                        const finalX = Math.max(0, Math.min(newX, (NUM_COLS * 40) - itemRect.width));
                        const finalY = Math.max(0, Math.min(newY, (NUM_ROWS * 40) - itemRect.height));

                        const finalRect = { ...itemRect, x: finalX, y: finalY };

                        if (isPositionOccupied(finalRect, itemId)) {
                            return zone; // No changes if position is occupied
                        }

                        const updatedItems = items.map(it => 
                            it.id == itemId ? { ...it, x: finalX, y: finalY, row: undefined, col: undefined } : it
                        );

                        if (itemType === 'table') {
                            return { ...zone, tables: updatedItems };
                        } else {
                            return { ...zone, decorations: updatedItems };
                        }
                    });
                    
                    setZones(updatedZones);
                    setIsDirty(true);
                };

                const handleCellClick = (row, col) => {
                    const x = (col - 1) * 40;
                    const y = (row - 1) * 40;

                    if (isAddingMode) {
                        setNewTableCoords({ x, y });
                        setShowAddTableModal(true);
                    } else if (isAddingDecorationMode) {
                        setNewDecorationCoords({ x, y });
                        setShowAddDecorationModal(true);
                    }
                };

                const handleAddDecoration = (type) => {
                    const typeInfo = DECORATION_TYPES[type];
                    if (typeInfo && typeInfo.isDrawable) {
                        setIsAddingWallMode(true);
                        setIsAddingMode(false);
                        setIsAddingDecorationMode(false);
                        return;
                    }

                    if (!newDecorationCoords) {
                        console.error("No coordinates to add decoration");
                        return;
                    }
                    const { x, y } = newDecorationCoords;
                    const newDecoration = { id: `decor-temp-${Date.now()}`, type, x, y };
                    const newDecoRect = getItemRect(newDecoration, 'decoration');

                    if (isPositionOccupied(newDecoRect, null)) {
                        alert("La posición ya está ocupada.");
                        return;
                    }

                    const updatedZones = zones.map(zone => {
                        if (zone.id === activeZoneId) {
                            return { ...zone, decorations: [...zone.decorations, newDecoration] };
                        }
                        return zone;
                    });
                    setZones(updatedZones);
                    setIsDirty(true);
                    setIsAddingDecorationMode(false);
                    setNewDecorationCoords(null);
                };

                const handleAddZone = (name) => {
                    const existingZone = zones.find(z => z.name === name);
                    if (existingZone) {
                        alert("Ya existe una zona con ese nombre.");
                        return;
                    }
                    const newZone = {
                        id: `zone-${Date.now()}`,
                        name: name,
                        tables: [],
                        decorations: [],
                        walls: []
                    };
                    const newZones = [...zones, newZone];
                    setZones(newZones);
                    setActiveZoneId(newZone.id);
                    setShowAddZoneModal(false);
                    setNewZoneName('');
                    setIsDirty(true);
                };

                const handleAddTable = (tableName, tableShape) => {
                    if (!newTableCoords) return;
                    const { x, y } = newTableCoords;

                    const newTable = {
                        id: `temp-${Date.now()}`,
                        number: tableName,
                        shape: tableShape,
                        x: x,
                        y: y,
                        descripcion: `Mesa ${tableName}`
                    };

                    const newTableRect = getItemRect(newTable, 'table');
                    if (isPositionOccupied(newTableRect, null)) {
                        alert('La posición ya está ocupada.');
                        return;
                    }

                    const updatedZones = zones.map(zone => 
                        zone.id === activeZoneId 
                            ? { ...zone, tables: [...zone.tables, newTable] } 
                            : zone
                    );
                    setZones(updatedZones);
                    setIsDirty(true);
                    setShowAddTableModal(false);
                    setIsAddingMode(false);
                    setNewTableCoords(null);
                };

                const handleRenameZone = () => {
                    const { id, name } = zoneToEdit;
                    const finalNewName = name.trim();
                    if (!finalNewName) return;

                    if (zones.some(z => z.name === finalNewName && z.id !== id)) {
                        return alert('Ya existe otra zona con ese nombre.');
                    }

                    setZones(zones.map(z => z.id === id ? { ...z, name: finalNewName } : z));
                    setIsDirty(true);
                    setShowZoneActionsModal(false);
                };

                const handleDeleteWall = () => {
                    if (!selectedWallId) return;

                    const newZones = zones.map(zone => {
                        if (zone.id === activeZoneId) {
                            return {
                                ...zone,
                                walls: zone.walls.filter(w => w.id !== selectedWallId)
                            };
                        }
                        return zone;
                    });

                    setZones(newZones);
                    setSelectedWallId(null);
                    setIsDirty(true);
                    setShowDeleteWallModal(false);
                };

                const handleEditDecoration = (updatedDeco) => {
                    const newZones = zones.map(zone => {
                        if (zone.id === activeZoneId) {
                            return {
                                ...zone,
                                decorations: zone.decorations.map(d => d.id === updatedDeco.id ? { ...d, ...updatedDeco } : d)
                            };
                        }
                        return zone;
                    });
                    setZones(newZones);
                    setIsDirty(true);
                    setShowEditDecorationModal(false);
                };

                const handleDeleteDecoration = (decorationId) => {
                    const newZones = zones.map(zone => {
                        if (zone.id === activeZoneId) {
                            return {
                                ...zone,
                                decorations: zone.decorations.filter(d => d.id !== decorationId)
                            };
                        }
                        return zone;
                    });
                    setZones(newZones);
                    setIsDirty(true);
                    setShowEditDecorationModal(false);
                };

                const handleDecorationDoubleClick = (e, deco) => {
                    setDecorationToEdit(deco);
                    setShowEditDecorationModal(true);
                };

                const handleSaveChanges = () => {
                    setIsSaving(true);
                    fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(zones)
                    })
                    .then(res => res.ok ? res.json() : Promise.reject(new Error('Failed to save')))
                    .then(result => {
                        if(result.success) {
                            alert('¡Plano guardado con éxito!');
                            fetchData();
                        } else {
                            alert('Error al guardar: ' + result.message);
                        }
                    })
                    .catch(err => {
                        console.error('Error saving layout:', err);
                        alert('Error al guardar el plano.');
                    })
                    .finally(() => setIsSaving(false));
                };

                const handleTableDoubleClick = (e, table) => {
                    if (e.altKey) {
                        if (confirm(`¿Seguro que quieres eliminar la mesa "${table.number}"?`)) {
                            const zone = zones.find(z => z.id === activeZoneId);
                            const newTables = zone.tables.filter(t => t.id !== table.id);
                            setZones(zones.map(z => z.id === activeZoneId ? { ...z, tables: newTables } : z));
                            if (selectedTable === table.id) {
                                setSelectedTable(null);
                            }
                            setIsDirty(true);
                        }
                    } else {
                        setTableToEdit(table);
                        setShowEditTableModal(true);
                    }
                };

                const handleDeleteFromModal = (tableId) => {
                    if (confirm("¿Seguro que quieres eliminar esta mesa?")) {
                        const zone = zones.find(z => z.id === activeZoneId);
                        const newTables = zone.tables.filter(t => t.id !== tableId);
                        setZones(zones.map(z => z.id === activeZoneId ? { ...z, tables: newTables } : z));
                        setSelectedTable(prev => prev === tableId ? null : prev);
                        setIsDirty(true);
                        setShowEditTableModal(false);
                    }
                };

                const handleEditTable = (tableId, newName, newShape) => {
                    const zone = zones.find(z => z.id === activeZoneId);
                    const newTables = zone.tables.map(table =>
                        table.id == tableId ? { ...table, number: newName, shape: newShape } : table
                    );
                    setZones(zones.map(z => z.id === activeZoneId ? { ...z, tables: newTables } : z));
                    setIsDirty(true);
                };

                const handleDeleteZone = () => {
                    const newZones = zones.filter(z => z.id !== activeZoneId);
                    setZones(newZones);
                    if (newZones.length > 0) {
                        setActiveZoneId(newZones[0].id);
                    } else {
                        setActiveZoneId(null);
                    }
                    setShowDeleteZoneModal(false);
                    setIsDirty(true);
                };

                const handleSelectWall = (wallId) => {
                    setSelectedWallId(wallId);
                };

                const handleWallDoubleClick = (wallId) => {
                    setSelectedWallId(wallId);
                    setShowDeleteWallModal(true);
                };

                return (
                    <div className="relative min-h-screen bg-yellow-50">
                        <AddZoneModal show={showAddZoneModal} onClose={() => setShowAddZoneModal(false)} value={newZoneName} onChange={(e) => setNewZoneName(e.target.value)} onSave={handleAddZone} />
                        <ZoneActionsModal 
                            show={showZoneActionsModal} 
                            onClose={() => setShowZoneActionsModal(false)}
                            value={zoneToEdit.name}
                            onChange={(e) => setZoneToEdit({ ...zoneToEdit, name: e.target.value })}
                            onSave={handleRenameZone}
                            onDelete={() => { 
                                setShowZoneActionsModal(false); 
                                setShowDeleteZoneModal(true); 
                            }}
                        />
                        <AddDecorationModal show={showAddDecorationModal} onClose={() => setShowAddDecorationModal(false)} onSave={handleAddDecoration} />
                        <AddTableModal show={showAddTableModal} onClose={() => setShowAddTableModal(false)} onSave={handleAddTable} />
                        <DeleteZoneModal show={showDeleteZoneModal} onClose={() => setShowDeleteZoneModal(false)} onConfirm={handleDeleteZone} zoneName={zones.find(z => z.id === activeZoneId)?.name || ''} />
                        <DeleteWallModal show={showDeleteWallModal} onClose={() => setShowDeleteWallModal(false)} onConfirm={handleDeleteWall} />
                        <EditTableModal show={showEditTableModal} onClose={() => setShowEditTableModal(false)} table={tableToEdit} onSave={handleEditTable} onDelete={handleDeleteFromModal} />
                        <EditDecorationModal show={showEditDecorationModal} onClose={() => setShowEditDecorationModal(false)} decoration={decorationToEdit} onSave={handleEditDecoration} onDelete={handleDeleteDecoration} />
                        <div className="relative flex h-screen">
                            <Sidebar {...{ getInitials, zones, activeZoneId, setActiveZoneId, isAddingMode, setIsAddingMode, isAddingDecorationMode, setIsAddingDecorationMode, isAddingWallMode, setIsAddingWallMode, selectedTable, setSelectedTable, setShowAddZoneModal, setShowDeleteZoneModal, setZoneToEdit, setShowZoneActionsModal, isSidebarOpen, setIsSidebarOpen, handleSaveChanges, isDirty, isSaving }} />
                            <div className={`flex-1 flex flex-col overflow-hidden transition-all duration-300 ${isSidebarOpen ? 'lg:ml-64 ml-20' : 'ml-20'}`}>
                                <Header activeZoneName={zones.find(z => z.id === activeZoneId)?.name || 'Sin Zonas'} isSidebarOpen={isSidebarOpen} setIsSidebarOpen={setIsSidebarOpen} />
                                <main className={`flex-1 overflow-auto p-4 sm:p-6 md:p-8 bg-gray-900 ${isAddingMode || isAddingDecorationMode || isAddingWallMode ? 'adding-mode' : ''}`}>
                                                                        <h1 className="hidden lg:block text-4xl font-bold text-white mb-8">Editor de Plano: {zones.find(z => z.id === activeZoneId)?.name || ''}</h1>
                                    <div className="bg-white p-4 rounded-lg shadow-md inline-block">
                                        {(() => {
                                            const activeZone = zones.find(z => z.id === activeZoneId);
                                            if (!activeZone) {
                                                return <div className="text-center text-gray-400 py-8">Selecciona una zona para ver las mesas o crea una nueva.</div>;
                                            }

                                            return (
                                                <div className="relative grid bg-gray-50" style={{ gridTemplateRows: `repeat(${NUM_ROWS}, 40px)`, gridTemplateColumns: `repeat(${NUM_COLS}, 40px)`}}
                                                     onDragOver={handleDragOver}
                                                     onDrop={handleDrop}
                                                     onMouseDown={handleMouseDownOnGrid}
                                                     onMouseMove={handleMouseMoveOnGrid}
                                                     onMouseUp={handleMouseUpOnGrid}
                                                     onMouseLeave={handleMouseUpOnGrid}>
                                                    {/* Render grid cells for background and dropping */}
                                                    {Array.from({ length: NUM_ROWS * NUM_COLS }).map((_, index) => {
                                                        const row = Math.floor(index / NUM_COLS) + 1;
                                                        const col = (index % NUM_COLS) + 1;
                                                        return (
                                                            <div key={`cell-${row}-${col}`} className="grid-cell border border-dashed border-gray-200" 
                                                                onDragLeave={handleDragLeave} 
                                                                onClick={() => {
                                                                    if (isAddingMode || isAddingDecorationMode) {
                                                                        handleCellClick(row, col);
                                                                    }
                                                                }}>
                                                            </div>
                                                        );
                                                    })}

                                                    {/* Render tables with absolute positioning */}
                                                    {activeZone.tables.map(table => {
                                                        const { shape, number, id } = table;
                                                        const rect = getItemRect(table, 'table');
                                                        return (
                                                            <div key={id} draggable onDragStart={(e) => handleDragStart(e, id, 'table')} onDoubleClick={(e) => handleTableDoubleClick(e, table)} onClick={(e) => { e.stopPropagation(); setSelectedTable(id); setIsAddingMode(false); setIsAddingDecorationMode(false); }} 
                                                                style={{
                                                                    position: 'absolute',
                                                                    left: rect.x,
                                                                    top: rect.y,
                                                                    width: rect.width,
                                                                    height: rect.height,
                                                                    cursor: 'move',
                                                                }}
                                                                className={`flex items-center justify-center bg-white border-2 ${selectedTable === id ? 'border-cyan-500' : 'border-gray-300'} text-gray-900 rounded-xl`}>
                                                                <span className="text-xl font-bold">{number}</span>
                                                            </div>
                                                        );
                                                    })}

                                                    {/* Render wall preview */}
                                                    {isDrawingWall && wallDrawing && (() => {
                                                        const isHorizontal = Math.abs(wallDrawing.endCol - wallDrawing.startCol) >= Math.abs(wallDrawing.endRow - wallDrawing.startRow);
                                                        
                                                        const finalRow = isHorizontal ? wallDrawing.startRow : wallDrawing.endRow;
                                                        const finalCol = isHorizontal ? wallDrawing.endCol : wallDrawing.startCol;

                                                        const startX = (Math.min(wallDrawing.startCol, finalCol) - 1) * 40;
                                                        const startY = (Math.min(wallDrawing.startRow, finalRow) - 1) * 40;
                                                        const wallLength = isHorizontal ? (Math.abs(wallDrawing.endCol - wallDrawing.startCol) + 1) * 40 : (Math.abs(wallDrawing.endRow - wallDrawing.startRow) + 1) * 40;

                                                        const style = {
                                                            left: `${startX}px`,
                                                            top: `${startY + (isHorizontal ? 18 : 0)}px`,
                                                            width: isHorizontal ? `${wallLength}px` : '5px',
                                                            height: isHorizontal ? '5px' : `${wallLength}px`,
                                                        };
                                                        return <div className="absolute bg-orange-400 opacity-70 rounded-full pointer-events-none" style={style}></div>;
                                                    })()}

                                                    {/* Render decorations with absolute positioning */}
                                                    {activeZone.decorations && activeZone.decorations.filter(deco => deco.type !== 'wall').map(deco => {
                                                        const typeInfo = DECORATION_TYPES[deco.type];
                                                        if (!typeInfo) return null;
                                                        return (
                                                            <div key={deco.id} draggable onDragStart={(e) => handleDragStart(e, deco.id, 'decoration')} onDoubleClick={(e) => handleDecorationDoubleClick(e, deco)}
                                                                className={`absolute flex items-center justify-center bg-transparent cursor-move`}
                                                                style={{
                                                                    top: `${deco.y}px`,
                                                                    left: `${deco.x}px`,
                                                                    width: `${(deco.width || typeInfo.width) * 40}px`,
                                                                    height: `${(deco.height || typeInfo.height) * 40}px`,
                                                                }}>
                                                                {typeInfo.isSvgIcon ?
                                                                    <Icon name={typeInfo.icon} className="w-full h-full text-slate-400" /> :
                                                                    <img src={deco.icon || typeInfo.icon} alt={typeInfo.name} className="w-full h-full object-cover pointer-events-none" />
                                                                }
                                                            </div>
                                                        );
                                                    })}

                                                    {/* Render walls */}
                                                    {activeZone.walls && activeZone.walls.map(wall => {
                                                        const isHorizontal = wall.startRow === wall.endRow;
                                                        const wallRect = getWallRect(wall);
                                                        const wallStyle = {
                                                            position: 'absolute',
                                                            left: `${wallRect.x}px`,
                                                            top: `${wallRect.y + (isHorizontal ? 18 : 0)}px`,
                                                            width: `${wallRect.width}px`,
                                                            height: `${wallRect.height}px`,
                                                            backgroundColor: selectedWallId === wall.id ? '#f87171' : '#94a3b8',
                                                            borderRadius: '9999px',
                                                            cursor: 'pointer',
                                                            zIndex: selectedWallId === wall.id ? 20 : 10
                                                        };

                                                        return <div key={wall.id} style={wallStyle} onClick={() => handleSelectWall(wall.id)} onDoubleClick={() => handleWallDoubleClick(wall.id)} />;
                                                    })}
                                                </div>
                                            );
                                        })()}
                                    </div>
                                </main>
                            </div>
                        </div>
                    </div>
                );
            }

            ReactDOM.render(<LayoutEditor />, document.getElementById('root'));
        }
    </script>

</body>
</html>
